---
title: DeDust.io
description: "This page list examples of working with DeDust, a decentralized exchange and automated market maker built natively on TON Blockchain and DeDust Protocol"
sidebar:
  order: 1
---

[DeDust](https://dedust.io) is a decentralized exchange (DEX) and automated market maker (AMM) built natively on [TON Blockchain](https://ton.org) and [DeDust Protocol 2.0](https://docs.dedust.io/reference/tlb-schemes). DeDust is designed with a meticulous attention to user experience (UX), gas efficiency, and extensibility.

## Recommended Reading

Before proceeding further, you may find it helpful to explore the following articles:

* [Receive messages](/book/receive/)
* [Sending messages](/book/send/)
* [Fungible Tokens (Jettons)](/cookbook/jettons/)

## Swaps

You can read more about swaps on [DeDust documentation](https://docs.dedust.io/docs/swaps).

:::caution

  It's important to ensure that contracts are deployed.
  Sending funds to an inactive contract could result in irretrievable loss.

:::

All kinds of swaps shares same structures:

```tact
struct SwapStep {
    poolAddress: Address; // The pool is responsible for swapping assets at this step.
    kind: Int as uint1 = 0; // Swap Kind. 0 always
    limit: Int as coins = 0; // Minimum output of the swap. If the actual value is less than specified, the swap will be rejected.
    nextStep: Cell?; // Reference to the next step. Can be used for multi-hop swaps. Should be `SwapStep`, but recursive types not supported in tact.
}

struct SwapParams {
    deadline: Int as uint32 = 0; // Specifies a deadline for the swap. If the swap reaches the Pool after this time, it will be rejected. 0 means disabled.
    recipientAddress: Address? = null; // Specifies an address where funds will be sent after the swap. Default: sender's address.
    referralAddress: Address? = null; // Referral address. Required for the Referral Program.
    fulfillPayload: Cell? = null; // Custom payload that will be attached to the fund transfer upon a successful swap.
    rejectPayload: Cell? = null; // Custom payload that will be attached to the fund transfer upon a rejected swap.
}
```

### Swapping native coin

```tact
message(0xea06185d) NativeSwap {
    queryId: Int as uint64 = 0;
    amount: Int as coins; // TON amount for the swap
    poolAddress: Address; // The pool is responsible for swapping assets at this step.
    kind: Int as uint1 = 0; // Swap Kind. 0 always
    limit: Int as coins = 0; // Minimum output of the swap. If the actual value is less than specified, the swap will be rejected.
    nextStep: SwapStep? = null; // Reference to the next step. Can be used for multi-hop swaps.
    swapParams: SwapParams; // Set of parameters relevant for the entire swap
}

// address of ton vault to send message
const TON_VAULT_ADDRESS: Address = address("EQDa4VOnTYlLvDJ0gZjNYm5PXfSmmtL6Vs6A_CZEtXCNICq_");

// address of pool to swap. Pool is pair like TON/USDT
const POOL_ADDRESS: Address = address("EQCY5ufIEA-wdv1L5Zw09OMDHywwHsqLKEAUBYtngwNnnal4");

const TON_SWAP_GAS_AMOUNT: Int = ton("0.2");

fun makeTonSwap() {
    let swapParams = SwapParams{
        deadline: 0,
        recipientAddress: null,
        referralAddress: null,
        fulfillPayload: null,
        rejectPayload: null,
    };

    // ton amount to swap in nanotons
    let swapAmount = ...;

    send(SendParameters{
        to: TON_VAULT_ADDRESS,
        value: swapAmount + TON_SWAP_GAS_AMOUNT,
        body: NativeSwap{
            queryId: 0,
            amount: swapAmount,
            poolAddress: POOL_ADDRESS,
            swapParams,
        }.toCell()
    });
}
```


### Swapping jetton

```tact
message(0xf8a7ea5) TokenTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address;
    customPayload: Cell?;
    forwardTonAmount: Int as coins;
    forwardPayload: Cell?;
}

message(0xe3a0d482) JettonSwapPayload {
    poolAddress: Address; // address of pool to swap. Pool is assets pair like TON/USDT
    kind: Int as uint1 = 0; // Swap Kind. 0 always
    limit: Int as coins = 0; // Minimum output of the swap. If the actual value is less than specified, the swap will be rejected.
    nextStep: SwapStep? = null; // Reference to the next step. Can be used for multi-hop swaps.
    swapParams: SwapParams; // Defined above
}

// address of jetton master you want to swap
const JETTON_MASTER_ADDRESS: Address = address("kQCxBOJjV31OIAa0NN9JbaYUp6OXOahcFCipuYnsujx1MDAY");

// address of jetton vault to send message
const JETTON_VAULT_ADDRESS: Address = address("EQCgne1aW1CmkokSeRjMIREmJWbCKFbJxxkRCvtLDiheTTF9");

// address of pool to swap. Pool is pair like TON/USDT
const POOL_ADDRESS: Address = address("EQCY5ufIEA-wdv1L5Zw09OMDHywwHsqLKEAUBYtngwNnnal4");

const JETTON_SWAP_GAS_AMOUNT: Int = ton("0.3");
const JETTON_SWAP_FWD_AMOUNT: Int = ton("0.25");

fun makeJettonSwap() {
    let swapParams = SwapParams{
        deadline: 0,
        recipientAddress: null,
        referralAddress: null,
        fulfillPayload: null,
        rejectPayload: null,
    };

    let myJettonWalletAddress = ...; // calculate wallet address of jetton you want to swap
    let swapAmount = ...; // jetton amount for swap

    send(SendParameters{
        to: myJettonWalletAddress,
        value: JETTON_SWAP_GAS_AMOUNT,
        body: TokenTransfer{
            queryId: 0,
            amount: swapAmount,
            destination: JETTON_VAULT_ADDRESS,
            responseDestination: myAddress(),
            forwardTonAmount: JETTON_SWAP_FWD_AMOUNT,
            forwardPayload: JettonSwapPayload{
                poolAddress: POOL_ADDRESS,
                swapParams,
            }.toCell()
        }.toCell()
    });
}
```


## Liquidity Provisioning

To provide liquidity to a specific DeDust pool, you must supply both assets. After doing so, the pool issues LP tokens to the depositor's address.

You can read more about liquidity provisioning on [DeDust documentation](https://docs.dedust.io/docs/liquidity-provisioning).

### Deposit liquidity

```tact
const PoolTypeVolatile: Int = 0;
const PoolTypeStable: Int = 1;

const AssetTypeNative: Int = 0b0000;
const AssetTypeJetton: Int = 0b0001;

const JettonProvideLpGas: Int = ton("0.5");
const JettonProvideLpGasFwd: Int = ton("0.4");
const TonProvideLpGas: Int = ton("0.15");

const JettonMaster: Address = address("kQDkRHlWaibL7Tww48T6xAUFevPflca7i8TIiQTacBmnDOrb");

const JettonVault: Address = address("kQDcUuH4xhKejjilZAIeGuBh5JRWpzbVDcO9Qfh_Q_K4q9vk");
const TonVault: Address = address("EQDa4VOnTYlLvDJ0gZjNYm5PXfSmmtL6Vs6A_CZEtXCNICq_");

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Cell?;
}

struct Asset {
    type: Int as uint4; // 0 for TON, 1 for Jetton
    workchain: Int? as uint8 = null;
    address: Int? as uint256 = null;
}

extends fun build(self: Asset): Cell {
    let assetBuilder = beginCell()
        .storeUint(self.type, 4);

    if (self.type == AssetTypeNative) {
        return assetBuilder.endCell();
    }
    if (self.type == AssetTypeJetton) {
        return assetBuilder
            .storeUint(self.workchain!!, 8)
            .storeUint(self.address!!, 256)
            .endCell();
    }

    require(false, "Unknown asset type");
    return beginCell().endCell();
}

message(0x40e108d6) JettonDepositLiquidity {
    poolType: Int as uint1; // Pool type. Maybe `Volatile` (0) - operates based on the formula: `x * y = k` or `Stable-Swap` which optimized for assets of near-equal value
    asset0: Asset;
    asset1: Asset;
    minimalLpAmount: Int as coins = 0; // Minimal received LP token. If less liquidity provision will be rejected.
    targetBalances0: Int as coins; // Target balance of first asset
    targetBalances1: Int as coins; // Target balance of second asset
    fulfillPayload: Cell? = null; // Custom payload that will be attached to the transaction after a successful swap LP.
    rejectPayload: Cell? = null; // Custom payload that will be attached to the transaction after a successful rejected LP.
}

extends fun build(self: JettonDepositLiquidity): Cell {
    return beginCell()
        .storeUint(0x40e108d6, 32)
        .storeUint(self.poolType, 1)
        .storeSlice(self.asset0.build().asSlice())
        .storeSlice(self.asset1.build().asSlice())
        .storeCoins(self.minimalLpAmount)
        .storeCoins(self.targetBalances0)
        .storeCoins(self.targetBalances1)
        .storeMaybeRef(self.fulfillPayload)
        .storeMaybeRef(self.rejectPayload)
        .endCell();
}

message(0xd55e4686) NativeDepositLiquidity {
    queryId: Int as uint64;
    amount: Int as coins; // TON amount to deposit.
    poolType: Int as uint1; // Pool type. Maybe `Volatile` (0) - operates based on the formula: `x * y = k` or `Stable-Swap` which optimized for assets of near-equal value
    asset0: Asset;
    asset1: Asset;
    minimalLpAmount: Int as coins = 0; // Minimal received LP token. If less liquidity provision will be rejected.
    targetBalances0: Int as coins; // Target balance of first asset
    targetBalances1: Int as coins; // Target balance of second asset
    fulfillPayload: Cell? = null; // Custom payload that will be attached to the transaction after a successful swap LP.
    rejectPayload: Cell? = null; // Custom payload that will be attached to the transaction after a successful rejected LP.
}

extends fun build(self: NativeDepositLiquidity): Cell {
    return beginCell()
        .storeUint(0xd55e4686, 32)
        .storeUint(self.queryId, 64)
        .storeCoins(self.amount)
        .storeUint(self.poolType, 1)
        .storeSlice(self.asset0.build().asSlice())
        .storeSlice(self.asset1.build().asSlice())
        .storeRef(
            beginCell()
                .storeCoins(self.minimalLpAmount)
                .storeCoins(self.targetBalances0)
                .storeCoins(self.targetBalances1)
                .endCell()
        )
        .storeMaybeRef(self.fulfillPayload)
        .storeMaybeRef(self.rejectPayload)
        .endCell();
}


message ProvideLp {
    myJettonWalletAddress: Address;
}

contract Example {
    receive() {}
    receive(msg: ProvideLp) {
        let jettonMasterRaw = parseStdAddress(JettonMaster.asSlice());

        // This example directly uses the `myJettonWalletAddress` provided in the received message.
        // In real-world scenarios, it's more reliable to calculate this address on-chain or save it during initialization to ensure accuracy and trustworthiness.
        let myJettonWalletAddress = msg.myJettonWalletAddress;

        // Step 1. Prepare input
        let jettonAmount = ton("1");
        let tonAmount = ton("1");

        let asset0 = Asset{
            type: AssetTypeNative,
        };
        let asset1 = Asset{
            type: AssetTypeJetton,
            workchain: jettonMasterRaw.workchain,
            address: jettonMasterRaw.address,
        };

        // Step 2. Deposit Jetton to Vault
        let jettonDepositBody = JettonDepositLiquidity{
            poolType: PoolTypeVolatile,
            asset0,
            asset1,
            targetBalances0: tonAmount,
            targetBalances1: jettonAmount,
        }.build();

        send(SendParameters{
            to: myJettonWalletAddress,
            value: JettonProvideLpGas,
            body: JettonTransfer{
                queryId: 42,
                amount: jettonAmount,
                destination: JettonVault,
                responseDestination: myAddress(),
                forwardTonAmount: JettonProvideLpGasFwd,
                forwardPayload: jettonDepositBody,
            }.toCell()
        });

        // Step 3. Deposit TON to Vault
        let nativeDepositBody = NativeDepositLiquidity{
            queryId: 42,
            amount: tonAmount,
            poolType: PoolTypeVolatile,
            asset0,
            asset1,
            targetBalances0: tonAmount,
            targetBalances1: jettonAmount,
        }.build();

        send(SendParameters{
            to: TonVault,
            value: tonAmount + TonProvideLpGas,
            body: nativeDepositBody,
        });
    }
}
```

### Withdraw liquidity

To withdraw liquidity, burning LP tokens is required. You can refer to examples of jetton burning [here](/cookbook/jettons#burning-jetton).

:::tip[Hey there!]

Didn't find your favorite example of DeDust interaction? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::
